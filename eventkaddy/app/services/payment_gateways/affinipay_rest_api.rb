require 'net/http'
require 'json'
require "uri"

module PaymentGateways
  class AffinipayRestApi

    def initialize secret_key
      @base_url   = URI('https://api.affinipay.com/v1/charges')
      @secret_key = secret_key
    end

    # amount => total amount, method => generated by afinipay payment form, account_id => merchant account id
    def make_charge amount, method, source_id, account_id = nil
      uri = URI(@base_url)

      req = Net::HTTP::Post.new(uri)
      req.basic_auth(@secret_key, '')
      req.content_type = 'application/json'

      request_body = {
        'amount' => amount.to_s,
        'method' => method
      }

      request_body['source_id']  = source_id if source_id
      request_body['account_id'] = account_id if account_id
      req.body = request_body.to_json
      req_options = {
        use_ssl: uri.scheme == 'https'
      }

      res = Net::HTTP.start(uri.hostname, uri.port, req_options) do |http|
        http.request(req)
      end

      return res
    end

    # charge_id => payment_id , amount => total amount needs to refund
    def refund_charge charge_id, amount
      uri = URI("#{@base_url}/#{charge_id}/refund")

      req = Net::HTTP::Post.new(uri)
      req.basic_auth(@secret_key, '')
      req.content_type = 'application/json'

      request_body = {
        'amount' => amount.to_s
      }.to_json

      req.body = request_body
      req_options = {
        use_ssl: uri.scheme == 'https'
      }

      res = Net::HTTP.start(uri.hostname, uri.port, req_options) do |http|
        http.request(req)
      end

      return res

    end

    def capture_charge charge_id, charge_amount
      uri = URI("#{@base_url}/#{charge_id}/capture")

      req = Net::HTTP::Post.new(uri)
      req.basic_auth(@secret_key, '')
      req.content_type = 'application/json'

      request_body = {
        'amount' => charge_amount.to_s
      }.to_json

      req.body = request_body
      req_options = {
        use_ssl: uri.scheme == 'https'
      }

      res = Net::HTTP.start(uri.hostname, uri.port, req_options) do |http|
        http.request(req)
      end

      return res

    end

    # check merchant details for account settings
    def merchant
      uri = URI("https://api.affinipay.com/v1/merchant")

      req = Net::HTTP::Get.new(uri)
      req.basic_auth(@secret_key, '')
      req.content_type = 'application/json'

      req_options = {
        use_ssl: uri.scheme == 'https'
      }

      res = Net::HTTP.start(uri.hostname, uri.port, req_options) do |http|
        http.request(req)
      end

      return res

    end

    # transaction details
    def transactions transaction_id
      uri = URI("https://api.affinipay.com/v1/transactions/#{transaction_id}")

      req = Net::HTTP::Get.new(uri)
      req.basic_auth(@secret_key, '')
      req.content_type = 'application/json'

      req_options = {
        use_ssl: uri.scheme == 'https'
      }

      res = Net::HTTP.start(uri.hostname, uri.port, req_options) do |http|
        http.request(req)
      end

      return res
    end

    class << self
      def create_payment_attendee mode_of_payment, payment_id, order
        secret_key = mode_of_payment.client_secret_key
        object     = self.new(secret_key)

        processing_fee_percentage = 3
        processing_fee = (order.total * processing_fee_percentage / 100.0).round()
        total_with_processing_fee = (order.total + processing_fee)*100

        unique_identifier = SecureRandom.uuid
        partner_name = "USCC"
        source_id = "#{partner_name}:#{unique_identifier}"

        # making the payments
        response   = object.make_charge(total_with_processing_fee, payment_id, source_id)
        response_data = JSON.parse response.body
        Rails.logger.info "#{response_data}"

        # tracking the order
        if response_data["id"].present?
          order.order_transactions.create(
                transaction_id: response_data["id"],
                transaction_status: response_data["status"],
                source_id: source_id
              )
        else
          if response_data["messages"].present? && response_data["messages"][0]["entity_id"].present?
            order.order_transactions.create(
                transaction_id: response_data["messages"][0]["entity_id"],
                transaction_status: "FAILED",
                source_id: source_id
              )
          end
        end

        if response.code == "200"
          charge_response = object.capture_charge(response_data["id"], total_with_processing_fee)
          return charge_response
        else
          return response
        end
      end

      def create_payment_exhibitor_v2 mode_of_payment, payment_id, order, category_ids, settings
        secret_key = mode_of_payment.client_secret_key
        object     = self.new(secret_key)
        sponsorship_with_booth_selection_category = ProductCategory.find_by( iid: 'sponsorship_with_booth_selection', event_id: mode_of_payment.event_id )
        total_amount                              = order.calculate_total_order_amount_v2(sponsorship_with_booth_selection_category, category_ids)

        if settings.transaction_tax_value.present?
          processing_fee = ((total_amount.to_i * settings.transaction_tax_value.to_i)/100).round()
          total_amount += processing_fee
        end

        # converting dollar to cent
        total_amount = total_amount * 100

        unique_identifier = SecureRandom.uuid
        partner_name      = mode_of_payment.merchant_partner_name.present? ? mode_of_payment.merchant_partner_name : 'USCC'
        source_id         = "#{partner_name}:#{unique_identifier}"

        # making the payments
        response          = object.make_charge(total_amount.to_i, payment_id, source_id, mode_of_payment.merchant_account_id)
        response_data     = JSON.parse response.body
        Rails.logger.info "#{response_data}"

        # tracking the order
        if response_data["id"].present?
          order.order_transactions.create(
            transaction_id: response_data["id"],
            transaction_status: response_data["status"],
            source_id: source_id
          )
        else
          if response_data["messages"].present? && response_data["messages"][0]["entity_id"].present?
            order.order_transactions.create(
              transaction_id: response_data["messages"][0]["entity_id"],
              transaction_status: "FAILED",
              source_id: source_id
            )
          end
        end

        if response.code == "200"
          charge_response = object.capture_charge(response_data["id"], total_amount.to_i)
          return charge_response
        else
          return response
        end

      end

      def create_payment_exhibitor transaction, cart, payment_id
        mode_of_payment = transaction.mode_of_payment
        secret_key      = mode_of_payment.client_secret_key
        object          = self.new(secret_key)
        total_amount    = cart.calculate_total_amount * 100

        unique_identifier = SecureRandom.uuid
        partner_name      = mode_of_payment.merchant_partner_name.present? ? mode_of_payment.merchant_partner_name : 'USCC'
        source_id         = "#{partner_name}:#{unique_identifier}"

        response          = object.make_charge(total_amount.to_i, payment_id, source_id, mode_of_payment.merchant_account_id)
        response_data     = JSON.parse response.body

        cart.create_order(transaction)
        order = Order.where(transaction_id: transaction.id).first

        if response_data["id"].present?
          if order
            transaction.update_columns( amount: order.total, external_status: response_data["status"], external_payment_id: response_data["id"])
            order.update_attribute(:status, "paid")
            order.order_transactions.create(
                transaction_id: response_data["id"],
                transaction_status: response_data["status"],
                source_id: source_id
              )
          end
        else
          if response_data["messages"].present? && response_data["messages"][0]["entity_id"].present?
            transaction.update_columns( amount: order.total, external_status: "FAILED" )
            order.update_attribute(:status, "failed")
            order.order_transactions.create(
                transaction_id: response_data["messages"][0]["entity_id"],
                transaction_status: "FAILED",
                source_id: source_id
              )
          end
        end

        if response.code == "200"
          charge_response = object.capture_charge(response_data["id"], total_amount.to_i)
          return charge_response
        else
          return response
        end
      end

      def create_refund charge_id, amount, secret_key
        object     = self.new(secret_key)
        response = object.refund_charge(charge_id, amount)
        return response
      end

      def refund_by_charge_id transaction_id, event_id
        mode_of_payment = ModeOfPayment.where(event_id: event_id, iid: 'affinipay').first
        secret_key = mode_of_payment.client_secret_key
        object     = self.new(secret_key)
        response = object.transactions(transaction_id)
        if response.code == "200"
          response_data = JSON.parse response.body
          refund_response = create_refund(transaction_id, response_data["amount"], secret_key)
          return refund_response
        else
          return response
        end
      end

    end

  end
end
